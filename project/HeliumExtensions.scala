package org.http4s.sbt

import cats.effect.{Resource, Sync}
import laika.ast._
import laika.bundle.ExtensionBundle
import laika.factory.Format
import laika.format.HTML
import laika.io.model.InputTree
import laika.parse.code.CodeCategory
import laika.render.HTMLFormatter
import laika.theme.Theme.TreeProcessor
import laika.theme.{Theme, ThemeBuilder, ThemeProvider, TreeProcessorBuilder}

/** Extensions for the Laika toolkit to implement features not yet available in Laika Core.
  *
  * These extensions are intended to live here until the next feature release of Laika (0.19),
  * which, as a very rough estimate, should be available sometime in spring/summer 2022.
  *
  * It consists of two extensions, one for implementing the Pretty-URL scheme that the http4s site
  * used when it was generated by Hugo. It's implemented and documented in the inner `PrettyURLs` type.
  * The other one (`CodeVariables`) enables variable substitutions in string literals in code blocks,
  * which is currently used solely for injecting version numbers from the build.
  *
  * Finally, the `applyTo` method applies these two extensions to an instance of default Helium configuration.
  */
object HeliumExtensions {

  /** Implements the Pretty-URL scheme previously used with the http4s site when it was generated by Hugo.
    *
    *  It consists of two parts: one (`treeProcessor`) re-arranges the document tree in a way that all pages
    *  are moved into a sub-directory with that page becoming the only content of the directory.
    *  The name of this document will always be `index.md`, meaning `someTitle.html` changes to `someTitle/index.html`.
    *
    *  The other part (`renderOverride`) overrides the default renderer for internal links to adjust them
    *  for the changes performed by the `treeProcessor`.
    */
  object PrettyURLs {

    def treeProcessor[F[_]: Sync]: TreeProcessor[F] = TreeProcessorBuilder[F].mapTree { tree =>
      val indexName = "README.md"

      def transformTree(tree: DocumentTree): DocumentTree = tree.copy(content = tree.content.map {
        case childTree: DocumentTree => transformTree(childTree)
        case doc: Document if doc.path.name == indexName => doc
        case doc: Document =>
          val treePath = doc.path.withoutSuffix
          DocumentTree(treePath, Seq(doc.copy(path = treePath / indexName)))
      })

      tree.copy(root = tree.root.copy(tree = transformTree(tree.root.tree)))
    }

    def adjustForPrettyURL(target: Target): Target = {

      def translateAbs(path: Path): Path =
        if (path.basename == "README" || !path.suffix.contains("md")) path
        else path.withoutSuffix.withoutFragment / ("index.md" + path.fragment.fold("")("#" + _))

      def translateRel(path: RelativePath): RelativePath =
        if (path.basename == "README" || !path.suffix.contains("md")) path
        else path.withoutSuffix.withoutFragment / ("index.md" + path.fragment.fold("")("#" + _))

      target match {
        case ext: ExternalTarget => ext
        case it: InternalTarget =>
          it match {
            case resIt: ResolvedInternalTarget =>
              resIt.copy(
                absolutePath = translateAbs(resIt.absolutePath),
                relativePath = translateRel(resIt.relativePath),
              )
            case relIt: RelativeInternalTarget => relIt.copy(path = translateRel(relIt.path))
            case absIt: AbsoluteInternalTarget => absIt.copy(path = translateAbs(absIt.path))
          }
      }
    }

    def renderTarget(fmt: HTMLFormatter, target: Target): String =
      fmt.pathTranslator.translate(adjustForPrettyURL(target)) match {
        case ext: ExternalTarget => ext.url
        case int: InternalTarget =>
          int.relativeTo(fmt.path).relativePath.toString.replace("index.html", "")
      }

    val renderOverride: PartialFunction[(HTMLFormatter, Element), String] = {
      case (fmt, SpanLink(content, target, None, opt)) =>
        fmt.element("a", opt, content, "href" -> renderTarget(fmt, target))
      case (_, bli: BulletListItem) if bli.hasStyle("nav-header") =>
        "" // skip fake-directories created for pretty-print URLs
    }
  }

  /** Implements variable substitutions for string literals in code blocks.
    *  Laika supports variable substitutions out of the box for regular markup, but not yet for use inside code blocks.
    *
    *  The syntax to be used inside code blocks is slightly different than the one for regular markup substitions,
    *  as its syntax (`${foo.bar}`) would conflict with many languages, including Scala. Instead, for code blocks,
    *  it has to written as `@{foo.bar}`.
    *
    *  The extension matches on AST nodes representing string literals, which means that it only works
    *  when Laika's internal syntax highlighters are active (by adding the `SyntaxHighlighting` extension to the build).
    */
  object CodeVariables {

    private val LaikaCodeSubstitution = "(.*)@\\{(.*)}(.*)".r

    def rewriteRules(variables: Map[String, String]): RewriteRules = RewriteRules.forSpans {
      case CodeSpan(content, cats, opts) if cats.contains(CodeCategory.StringLiteral) =>
        content match {
          case LaikaCodeSubstitution(pre, varName, post) =>
            val newNode = variables
              .get(varName)
              .fold[Span](
                InvalidSpan(s"Unknown variable: '$varName'", laika.parse.GeneratedSource)
              )(value => CodeSpan(pre + value + post, cats, opts))
            Replace(newNode)
          case _ => Retain
        }
    }

  }

  /** Applies the two feature extensions implemented by this class to a default Helium configuration instance.
    *
    * @param helium the Helium configuration as set up by other parts of this build
    * @param variables key/value mappings for variable substitutions that can be used in markup and code blocks
    * @param versionLinks all known paths of configured versions of the site, for link validation
    * @return a theme provider that merges the default Helium theme with the two extensions from this class
    */
  def applyTo(
      helium: ThemeProvider,
      variables: Map[String, String],
      versionLinks: Seq[Path],
  ): ThemeProvider = new ThemeProvider {

    override def build[F[_]: Sync]: Resource[F, Theme[F]] = {
      val heliumTheme = helium.build[F]
      val extensionTheme = ThemeBuilder[F]("Extensions for http4s")
        .processTree(PrettyURLs.treeProcessor, HTML)
        .addRenderOverrides(HTML.Overrides(PrettyURLs.renderOverride))
        .addRewriteRules(CodeVariables.rewriteRules(variables))
        .addInputs(InputTree[F].addProvidedPaths(versionLinks))
        .build
      for {
        hel <- heliumTheme
        ext <- extensionTheme
      } yield new Theme[F] {
        override def inputs: InputTree[F] = hel.inputs ++ ext.inputs
        override def extensions: Seq[ExtensionBundle] = hel.extensions ++ ext.extensions
        override def treeProcessor: Format => TreeProcessor[F] = fmt =>
          hel.treeProcessor(fmt).andThen(ext.treeProcessor(fmt))
      }
    }
  }

}
